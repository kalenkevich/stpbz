<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <TITLE>12. Ассоциативный поиск.</TITLE>
    <p><a href="Тема 7.1.htm">Предыдущая </a>
        <a href="Тема 8.1.htm"> Следующая</a></p>
    <META NAME="GENERATOR" CONTENT="LibreOffice 4.0.5.2 (Linux)">
    <META NAME="AUTHOR" CONTENT="User">
    <META NAME="CREATED" CONTENT="20150304;20020000">
    <META NAME="CHANGEDBY" CONTENT="User">
    <META NAME="CHANGED" CONTENT="20150304;20450000">
    <META NAME="AppVersion" CONTENT="14.0000">
    <META NAME="Company" CONTENT="SPecialiST RePack">
    <META NAME="DocSecurity" CONTENT="0">
    <META NAME="HyperlinksChanged" CONTENT="false">
    <META NAME="LinksUpToDate" CONTENT="false">
    <META NAME="ScaleCrop" CONTENT="false">
    <META NAME="ShareDoc" CONTENT="false">
    <STYLE TYPE="text/css">
        <!--
        @page {
            margin-left: 1.18in;
            margin-right: 0.59in;
            margin-top: 0.79in;
            margin-bottom: 0.49in
        }

        P {
            margin-bottom: 0.08in;
            direction: ltr;
            line-height: 100%;
            widows: 2;
            orphans: 2
        }

        P.western {
            font-family: "Times New Roman", serif;
            font-size: 14pt
        }

        P.cjk {
            font-family: "Times New Roman";
            font-size: 14pt;
            so-language: ru-RU
        }

        P.ctl {
            font-family: "Times New Roman";
            font-size: 12pt
        }

        H3 {
            text-indent: 0.49in;
            margin-top: 0in;
            margin-bottom: 0in;
            direction: ltr;
            line-height: 150%;
            text-align: justify;
            widows: 2;
            orphans: 2
        }

        H3.cjk {
            font-family: "Times New Roman";
            so-language: ru-RU
        }

        H3.ctl {
            font-family: "Times New Roman";
            font-size: 12pt
        }

        -->
    </STYLE>
</HEAD>
<BODY LANG="ru-RU" DIR="LTR">
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <FONT SIZE=4><B>Тема 12. Ассоциативный поиск</B></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in; margin-bottom: 0in; line-height: 145%">
    <B>12.1. Многоключевой поиск.</B></P>
<H3 CLASS="western" STYLE="line-height: 145%">12.1.1. Общие
    сведения о многоключевом поиске.</H3>
<P CLASS="western" STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 145%">
    В отличие от таблиц символов, в которых
    обычно существует</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 145%">
    взаимно однозначное соответствие между
    ключевым словом и связанным с ним
    значением, в разного рода справочниках,
    списках заказчиков и других документах,
    содержащих информацию описательного
    характера, как правило, каждый запоминаемый
    элемент данных снабжается несколькими
    ключевыми словами, или <I>дескрипторами</I>,
    причем одно и то же ключевое слово может
    присутствовать в произвольном количестве
    записей.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 145%">
    Если возникает необходимость в частой
    выборке всех элементов, отвечающих
    заданному ключу, наиболее выгодными с
    точки зрения общих затрат считаются
    <I>последовательные методы поиска</I>,
    например, как в <I>задаче селективного
    отбора </I>информации в библиотеке.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 145%">
    При нерегулярных одиночных обращениях
    к БД <I>адресация по содержанию</I> имеет
    явные преимущества по сравнению с
    <I>последовательным поиском </I>(например,
    при оформлении банковских операций,
    поиске архивных документов и т.д.).</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 145%">
    Учитывая разнообразие задач и особенности
    поиска информации в них, рассмотрим
    основные подходы к организации некоторых
    стандартных методов поиска информации
    по многим ключевым словам (многоключевой
    поиск) и их реализации с помощью методов
    хеширования.</P>
<H3 CLASS="western"><FONT SIZE=4></FONT>12.1.2. Списки и
    списочные структуры</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 145%">
    <I>Список</I> представляет собой любой
    упорядоченный набор элементов данных;
    если элемент списка сам по себе является
    списком, то такую конструкцию называют
    <I>списочной структурой.</I><SPAN LANG="en-US">C</SPAN>писок
    или списочные структуры хранятся в
    памяти в виде отдельной записи, списку
    присваивается имя, называемое <I>заголовком,</I>
    обычно это первый элемент списка. Поиск
    заголовков удобно проводить <I>методами
    хеширования.</I> К списку могут присоединяться
    различными способами дополнительные
    элементы (самый простой – использование
    <I>последовательно расположенных ячеек</I>).
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 150%">
    <I>Цепочка резервных ячеек</I> может
    служить примером списка, элементы
    которого разбросаны по некоторой области
    памяти, вычисленный адрес при этом
    играет роль заголовка списка.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.59in; margin-bottom: 0in; line-height: 150%">
    При обращении к списку последовательность
    адресов либо вычисляется при помощи
    <I>пробинга</I>, либо определяется
    посредством <I>указателей</I>.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 150%">
    Связанная указателями любая совокупность
    элементов данных называется <I>связанным
    списком</I>.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 150%">
    Различные виды связанных списков
    показаны на рис. 12.1.
</P>

<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 150%">
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_d5dbdcb.png" NAME="Рисунок 402" ALIGN=BOTTOM WIDTH=624 HEIGHT=373
         BORDER=0></P>

В списочной структуре, в некоторых ее
элементах, называемых <I>вершинами</I>,
имеется не менее чем по два указателя.
Если списочная структура начинает
ветвиться из вершины, именуемой в этом
случае <I>корнем</I>, и в ней отсутствуют
циклические цепочки элементов, ее
называют <I>деревом.</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 130%">
    Списочная структура с циклическими
    участками представляет собой <I>граф</I>.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    На рис. 12.2 приведен пример <I>бинарного
    дерева, </I>в которомиз каждой вершины
    (кроме последних элементов) всегда
    исходят по две ветви.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_m60ae854a.png" NAME="Рисунок 547" ALIGN=BOTTOM WIDTH=580 HEIGHT=322
         BORDER=0></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 125%">
    <BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <B>12.1.3. Мультисписки</B></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <I>Мультисписками </I>называют структуры,
    в которых имеются независимые цепочки,
    проходящие через один и тот же набор
    элементов, т.е. входящих в несколько
    списков, каждый из которых начинается
    с <I>заголовка </I>ипредставляет собой
    простую неветвящуюся цепочку<I>. </I>Для
    различения цепочек в ячейках наряду с
    указателями помещаются также идентификаторы
    заголовков соответствующих частных
    списков (рис. 12.3).</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_m73382d28.png" NAME="Рисунок 548" ALIGN=BOTTOM WIDTH=457 HEIGHT=212
         BORDER=0></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    На рис. 12.4 приведена структура типового
    мультисписка.
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_7fb7686e.png" NAME="Рисунок 549" ALIGN=BOTTOM WIDTH=569 HEIGHT=524
         BORDER=0></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in; margin-bottom: 0in; line-height: 120%">
    В справочнике мультисписка хранятся
    все ключевые слова, указатели первых
    элементов каждого списка и числа,
    задающие количество элементов в списках;
    его можно поместить в отдельной области
    памяти. Ключевые слова либо сортируются,
    либо путем хеширования адресов
    распределяются по ячейкам таблицы.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 120%">
    В ячейку памяти должны поместиться
    наряду с данными и управляющими битами
    <SPAN LANG="en-US"><I>m</I></SPAN> идентификаторов и
    <SPAN LANG="en-US"><I>m</I></SPAN> указателей (<SPAN LANG="en-US"><I>m</I></SPAN><I>
    – </I>максимальное количество ключевых
    слов в записи).</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 120%">
    При формировании мультисписковой
    структуры (обычно в процессе записи
    информации) вначале устанавливается
    местонахождение заголовков, содержащих
    ключевые слова нового элемента, затем
    – прослеживаются цепочки, идущие от
    заголовков. В последнюю запись каждой
    из цепочек заносится указатель,
    представляющий собой адрес ячейки
    нового элемента, который становится
    последним членом всех этих цепочек.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 120%">
    Выборка информации производится чаще
    всего по совокупности двух или более
    ключевых слов, просмотр ключей при этом
    целесообразно вести вдоль более короткой
    цепочки. Такой просмотр возможен лишь
    при условии, что вместе с каждым элементом
    данных хранятся все его ключевые слова
    или идентификаторы.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 120%">
    <FONT SIZE=4>Входящие в мультисписок отдельные
        списки могут достигать довольно больших
        размеров, в связи с чем при добавлении
        к списку новых элементов потребуются
        значительные временные затраты, так
        как придется просматривать всю ранее
        сформированную цепочку. При удалении
        элементов возникают аналогичные
        трудности. Их решение возможно путем
    </FONT><FONT SIZE=4><I>ограничения длины цепочек.</I></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 120%">
    Например, мультисписок на рис. 12.4 можно
    разделить на фрагменты, длина каждого
    из которых не превышает некоторой
    максимальной фиксированной величины,
    при этом в <I>справочник мультисписка</I>
    необходимо занести указатели всех
    фрагментов. Тогда каждый новый элемент
    будет добавляться к последнему частичному
    списку (<I>фрагменту</I>), более короткому,
    чем соответствующая полная цепочка
    мультисписка обычного типа (рис. 12.5).</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 120%">
    Предельная длина не фиксируется в так
    называемых <I>блочных мультисписках</I>,
    однако в них каждый из фрагментов должен
    располагаться в</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 120%">
    пределах одного физического блока
    памяти , например дорожки (ячейки,
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 120%">
    клетки и др.), рис. 7.12.
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_m6393e24a.png" NAME="Рисунок 550" ALIGN=BOTTOM WIDTH=548 HEIGHT=449
         BORDER=0></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <IMG SRC="Тема 7.2.files/image12.6.png" NAME="Рисунок 551" ALIGN=BOTTOM WIDTH=558 HEIGHT=506 BORDER=0></P>
<p style="text-align: center">Рис. 12.6. Блочный мультисписок</p>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    При буферизации стандартного блока в
    этом случае в ОП пересылаются все данные,
    содержащиеся в некотором частичном
    списке, причем по справочнику можно
    определить, какие блоки можно исключать
    из рассмотрения. Например, ячейку <FONT SIZE=5>3</FONT>
    можно не проверять, если необходимо
    выполнить комбинационный поиск по
    аргументу <SPAN LANG="en-US"><I>X</I></SPAN><I> и </I><SPAN LANG="en-US"><I>Y</I></SPAN>,
    так как в ней нет записей с ключом <SPAN LANG="en-US"><I>Y</I></SPAN>
    (только с ключами <SPAN LANG="en-US"><I>W</I></SPAN>и
    <SPAN LANG="en-US"><I>Z</I></SPAN>). Можно также сократить
    продолжительность поиска, выбирая для
    просмотра ячейки, относящиеся к наиболее
    коротким цепочкам ( ячейки 0и 1в цепочке
    <SPAN LANG="en-US"><I>Y</I></SPAN> или ячейка 2 в цепочке
    <SPAN LANG="en-US"><I>X</I></SPAN> ).</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    При сочетании блочного мультисписка и
    клеточной организации образуется
    <I>блочная последовательная структура,
    </I>изображенная на рис. 12.7, для которой
    в справочник заносятся только индексы
    блоков, имеющих записи, содержащие
    определенные ключевые слова. Опрос
    соответствующих ячеек в этом случае
    производится последовательно.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%; text-align: center">
    <IMG SRC="Тема 7.2.files/image12.7.png" NAME="Рисунок 552" ALIGN=BOTTOM WIDTH=547 HEIGHT=519 BORDER=0></P>
<p style="text-align: center">Рисунок 12.7. Блочная последовательная структура</p>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Частным случаем блочной последовательной
    структуры, каждый блок которой состоит
    из одной ячейки, является <I>инвертированный
    список </I>(рис. 12.8). В отличие от всех
    предыдущих способов многоключевого
    поиска, в которых ключевые слова
    располагаются в самой записи, в
    инвертированном списке адреса всех
    записей, связанных с данным ключевым
    словом, хранятся в справочнике. Справочник
    списка можно построить аналогично
    <I>индексной таблице хеширования.</I>
    Ключевые слова при этом играют роль
    вычисленных адресов <SPAN LANG="en-US"><I><B>v</B></I></SPAN>,
    а адреса записей соответствуют указателям
    элементов, расположенных во внешней
    памяти.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%;text-align: center">
    <IMG SRC="Тема 7.2.files/image12.8.png" NAME="Рисунок 1" ALIGN=BOTTOM WIDTH=421 HEIGHT=501 BORDER=0></P>
<p style="text-align: center">Рисунок 12.8. Инвертированный список</p>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Для поиска ключевых слов, если они в
    справочнике списка рассортированы в
    определенном порядке, можно применить
    любой стандартный метод, а указатели
    разместить в следующих друг за другом
    ячейках памяти.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    В инвертированном списке вся информация,
    участвующая в процессе поиска, занимает
    сравнительно немного места, благодаря
    чему справочник
</P>
<P ALIGN=JUSTIFY STYLE="line-height: 130%">можно хранить
    в ОП (для файлов не очень большого
    размера), что позволяет сократить до
    минимума в ЦП все подготовительные
    операции, предшествующие выборке из
    внешней памяти. Это является основным
    достоинством инвертированного списка.</P>
<P ALIGN=JUSTIFY STYLE="text-indent: 0.5in; line-height: 130%"><B>12.1.4.
    Использование составных ключевых слов
    в процедурах </B>
</P>
<P ALIGN=JUSTIFY STYLE="text-indent: 1in; line-height: 130%"><B>хеширования</B></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    В отличие от методики многоключевого
    поиска, основанной на выделении
    совпадающих элементов в списках,
    связанных с различными ключевыми
    словами, имеется и другой подход, в
    котором все ключи, входящие в некоторую
    запись, рассматриваются как <I>единое
    составное ключевое слово.</I> При полном
    наборе ключевых слов поиск можно
    осуществить так же, как и с одним ключевым
    словом. Задача усложняется, если часть
    ключей <I>не задана</I>.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Далее рассматриваются некоторые варианты
    использования составных ключевых слов
    при хешировании.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <I>Хеширование по всем сочетаниям ключевых
        слов</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Этот метод требует самых больших затрат
    памяти, хотя и обеспечивает при этом
    высокое быстродействие. Так, если в
    запись входит <SPAN LANG="en-US"><I>n</I></SPAN> ключевых
    слов, то существует
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_m177ee264.gif" ALIGN=BOTTOM><IMG
        SRC="Тема 7.2.files/i_6936822e08b74235_html_m177ee264.gif" ALIGN=BOTTOM><IMG
        SRC="Тема 7.2.files/i_6936822e08b74235_html_4fdb0433.gif" style="width: 60px; height: 69px" ALIGN=BOTTOM>
    различных комбинаций, для каждой из
    которых в хеш-таблице должна храниться
    копия записи.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Приведем стандартную процедуру
    формирования хеш-адреса по составному
    ключу.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Пусть по ключевым словам <SPAN LANG="en-US"><I>k</I></SPAN><SUB><I>1</I></SUB><I>,
</I><SPAN LANG="en-US"><I>k</I></SPAN><SUB><I>2</I></SUB><I>, …,</I><SPAN LANG="en-US"><I>k</I></SPAN><SUB><SPAN
        LANG="en-US"><I>k</I></SPAN></SUB>
    при помощи одного и того же алгоритма
    хешированияполученысоответствующие
    битовые строки<SPAN LANG="en-US"><I>B</I></SPAN>(<SPAN LANG="en-US"><I>k</I></SPAN><SUB><I>1
</I></SUB>)<I>, </I>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 130%">
    <SPAN LANG="en-US"><I>B</I></SPAN>(<SPAN LANG="en-US"><I>k</I></SPAN><SUB><I>2</I></SUB>)<I>,
    …, </I><SPAN LANG="en-US"><I>B</I></SPAN>(<SPAN LANG="en-US"><I>k</I></SPAN><SUB><SPAN LANG="en-US"><I>k</I></SPAN></SUB>)<I>,</I>
    по длине совпадающие с хеш-адресом.
    Хеш-адрес в этом случае можно определить
    как битовую строку <SPAN LANG="en-US"><I>B</I></SPAN>,
    которая вычисляется по следующей
    формуле:</P>
<P CLASS="western" ALIGN=CENTER STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <IMG SRC="Тема 7.2.files/form1.png" ALIGN=BOTTOM></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 130%">
    где символ
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_m2f5f253b.gif" style="width: 20px; height: 22px" ALIGN=BOTTOM> –
    операция “Исключающее ИЛИ”, т.е. операция
    “+” одноименных разрядов по модулю 2.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Если разделить все ключевые слова на
    группы по функциональному признаку,
    объем хеш-таблицы можно несколько
    сократить.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Предположим, что атрибуты <SPAN LANG="en-US"><I>A</I></SPAN><SUB><I>1</I></SUB><I>,
</I><SPAN LANG="en-US"><I>A</I></SPAN><SUB><I>2</I></SUB><I>, </I><SPAN LANG="en-US"><I>A</I></SPAN><SUB><I>3</I></SUB>
    (например, “<I>национальность</I>”,
    “<I>возрастная группа</I>” и “<I>местожительство</I>”
    граждан) имеют соответственно значения
    <SPAN LANG="en-US"><I>x</I></SPAN><SUB><I>1</I></SUB><I>, </I><SPAN
        LANG="en-US"><I>x</I></SPAN><SUB><I>2</I></SUB><I>,
</I><SPAN LANG="en-US"><I>x</I></SPAN><SUB><I>3</I></SUB>. Тогда
    уже по виду заданного <SPAN LANG="en-US"><I>x</I></SPAN><SUB><SPAN LANG="en-US"><I>i</I></SPAN></SUB>
    можно установить значение <SPAN LANG="en-US"><I>i</I></SPAN>
    (1, 2 или 3), что позволяет однозначно
    идентифицировать каждый из компонентов
    составного ключевого слова и каждому
    типу комбинации ключей поставить в
    соответствие <B>отдельную таблицу
    хеширования</B>.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    В данном примере отдельные таблицы
    должны быть сформированы для составных
    слов
    <IMG SRC="Тема 7.2.files/form2.png" ALIGN=BOTTOM style="margin-bottom: -10px">.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Цепочки резервных ячеек в таких частичных
    хеш-таблицах существенно короче, чем в
    общей таблице, поэтому их обработка
    значительно упрощается.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Сократить хеш-таблицу можно также
    хешированием лишь по наиболее вероятным
    или по <U>наиболее длинным</U> комбинациям
    ключевых слов. По остальным комбинациям
    производится отдельный поиск, но если
    их число слишком велико, такие способы
    неприемлемы.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Один из вариантов частичного преодоления
    этой трудности заключается
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 130%">
    в построении с<I>цепленного хеш-адреса.</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    С учетом того, что хеш-адрес представляет
    собой битовую строку, его можно формировать
    так, чтобы каждый из ключей, входящих в
    составное ключевое слово, определял
    свою группу битов. Полученные биты
    сцепляются, образуя <I>полный хеш-адрес</I>.
    Если, к примеру, каждому ключевому слову
    в адресе соответствует 2 бита, то функция
    хеширования от этого ключа может
    принимать лишь 4 различных значения:
    (00, 01, 10, 11). Следовательно, если в составном
    аргументе не заданы значения <SPAN LANG="en-US"><I>k</I></SPAN>
    ключевых слов, то поиск производится
    только для 4<SUP><SPAN LANG="en-US"><I>k</I></SPAN></SUP>
    сочетаний битов в соответствующих
    группах. Это дает возможность реализовать
    достаточно эффективную процедуру
    многоключевого поиска, хотя при этом
    сцепленные адреса распределяются по
    таблице менее равномерно, чем при обычном
    хешировании, и скорость поиска несколько
    снижается.
</P>
<H3 CLASS="western" STYLE="line-height: 130%"><BR>
</H3>
<H3 CLASS="western" STYLE="line-height: 130%">12.2 Применение
    методов хеширования для поиска по
    соответствию</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    В технических системах обработки данных
    по ряду объективных причин информация
    представляется как последовательность
    символов двоичного алфавита. Такое
    представление информации с ростом
    сложности решаемых задач все более
    проявляется как чужеродное человеческому
    мышлению.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 130%">
    В памяти технических систем в процессе
    запоминания изображения (отражение
    одного объекта на другом), его пересылки
    из одного ЗУ в другие не происходит
    обобщений, выделения каких-либо
    отличительных признаков, стирания
    второстепенных деталей [9].</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 130%">
    В памяти человека восприятие объекта
    из внешнего мира сопровождается
    возникновением эмоций, запоминается
    не только информация об объекте, но и
    вызванные им эмоциональные ощущения.
    Хранящийся в памяти образ (отображение
    объекта в сознании субъекта) содержит
    информацию о раздражителе из внешней
    среды, о субъективных эмоциях организма,
    вызванных появлением раздражителя, о
    времени воздействия данного раздражителя.
    В процессе формирования и запоминания
    образа происходит такая его обработка,
    которая соотносит данный образ с
    определенным классом уже хранящихся
    образов, т.е. осуществляется ассоциирование
    запоминаемого образа с уже запомненными
    и формирование понятий о классе образов.
    Процесс запоминания связан с образованием
    следа в мозговых структурах: поток
    нервных импульсов, несущих информацию
    об объекте, проходит через нейронные
    сети, возбуждая на своем пути нервные
    клетки, из которых формируется нейронный
    след. В организованных случайным образом
    нейронных сетях следы памяти расределяются
    по пространству мозга также случайно.
    След от одного объекта может иметь общие
    звенья нейронной сети от других объектов,
    поэтому нельзя указать точно, в каком
    месте мозга будет находиться след
    конкретного объекта информации –
    образа. Механизм доступа к информации
    должен базироваться не на указании
    места хранения информации в среде, а на
    анализе свойств самой искомой информации.
    Таким механизмом является механизм
    ассоциаций. Применительно к системам
    обработки данных, ассоциация – это
    взаимосвязь между информацией на входе
    запоминающей среды и информацией,
    хранящейся в запоминающей среде.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Процесс выборки данных из биологической
    памяти, вероятно, более близок к работе
    устройств <I>распознавания образов, </I>в
    которыхобъект представляется в виде
    <I>набора сигналов </I>(часто именуемых
    <I>признаками</I>), формируемых во времени
    либо параллельно, либо последовательно.
    В результате анализа <I>признаков</I>
    выдается решение, позволяющее либо
    идентифицировать объект, либо причислить
    его к определенному классу. Решение
    принимается исходя из сравнения
    результатов, полученных для различных<I>
    дискриминантных функций </I>(для каждой
    категории объектов – своя функция) при
    подстановке в них соответствующих
    наборов входных сигналов.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Для дискретных значений признаков
    процедуры классификации можно построить
    на базе методов хеширования, одна из
    них непосредственно реализует способ
    выборки, названный <I>поиском по
    соответствию </I>[9].</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Предлагаемый метод будет рассматриваться
    применительно к задаче идентификации
    слов по аргументу поиска, который
    представляет собой искаженный вариант
    одного из хранящихся в памяти слов,
    предполагается при этом коррекция
    неправильно заданных аргументов.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <I>Процедура выделения признаков </I>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    В рассматриваемом примере ключевое
    слово раскладывается на ряд признаков,
    каждый из которых представляет собой
    небольшую группу букв, причем эти группы
    могут накладываться друг на друга.
    Каждая группа формируется из последовательно
    расположенных букв, в этом случае
    локальные ошибки сказываются на
    минимальном количестве признаков.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Возможно образование групп по <I>циклическому
    принципу</I> из букв, стоящих в конце и
    начале слова, но при этом в группе следует
    соблюдать тот же порядок букв, что и в
    исходном слове, чтобы различать слова,
    полученные друг из друга путем циклической
    перестановки букв (например <I>строго</I>и
    <I>острог</I>). Пусть локальные признаки
    имеют 3 буквы, тогда слову <I>строго
</I>соответствует такой набор признаков:<I>
    стр, тро, рог,ого,сто, сго.</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Формируемые из <SPAN LANG="en-US"><I>n</I></SPAN>
    циклически последовательных символов
    признаки далее будут называться
    <SPAN LANG="en-US"><I>n</I></SPAN><I>-граммами</I>
    (<I>монограммами, биграммами, триграммами
</I>и<I> квадриграммами</I> при <SPAN LANG="en-US"><I>n</I></SPAN><I>
    = </I>1, 2, 3и4 соответственно).</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    Оптимальный выбор количества символов,
    образующих признак, определяется в
    каждом конкретном случае как содержанием
    ключевых слов, так и их количеством,
    однако следует отметить, что выбор типа
    признака не должен прямо зависеть от
    размера поискового аргумента, так как
    ошибки, связанные с пропуском или
    появлением лишних букв, могут приводить
    к изменению длины аргумента по сравнению
    с исходным ключевым словом.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    <I>Хеширование по признакам</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    В строке символов, из которых формируются
    признаки, могут быть ошибки трех видов:</P>
<OL>
    <LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 110%">
        ошибки <I>замены</I> (одна буква заменена
        другой);</P>
    <LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 110%">
        ошибки <I>включения</I> (введена
        дополнительная буква);</P>
    <LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 110%">
        ошибки <I>исключения</I> (буква пропущена).</P>
</OL>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    В случае ошибки типа включения или
    исключения, позиции всех букв, расположенных
    справа от того места, где она произошла,
    меняются. Это не происходит лишь в
    случае, когда две ошибки противоположного
    типа расположены рядом и компенсируют
    действие друг друга, если расположены
    не рядом – после второй ошибки позиции
    букв тоже не меняются.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    Для сохранения возможно большего
    количества правильных хеш-адресов в
    поисковом аргументе, несмотря на
    возможные искажения, могут применяться
    разные методы. Одним из наиболее простых
    является следующая комбинированная
    процедура. Она состоит из двух этапов:</P>
<OL>
    <LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 110%">
        вычисляются функции хеширования для
        локальных признаков (<SPAN LANG="en-US">n</SPAN>-грамм),
        не зависящие от их позиций в поисковом
        аргументе;</P>
</OL>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.53in; margin-bottom: 0in; line-height: 110%">
    2) осуществляется комбинационный поиск,
    в котором эти признаки используются
    как <I>ключевые слова</I>.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    Затем отбрасываются слова, у которых
    признаки по сравнению с поисковым
    аргументом смещены свыше заданной
    величины. Например, при смещении более
    чем на 2 позиции сохраняется возможность
    идентификации слов, содержащих двойные
    ошибки любых типов, так как маловероятно,
    чтобы в ключевых словах (длина их редко
    превосходит 10 позиций) могли одновременно
    возникнуть три однотипных ошибки
    (включения или исключения), причем вблизи
    друг друга;</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    Пусть в качестве признаков употребляются
    <U>только триграммы и используется
        латинский алфавит </U>(всего 26 букв).
    Буквы, входящие в триграмму, обозначим
    <IMG SRC="Тема 7.2.files/form3.png" style="margin-bottom: -10px" ALIGN=BOTTOM>, а
    триграмме поставим в соответствие
    величину
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 110%">
    <IMG SRC="Тема 7.2.files/form4.png" ALIGN=BOTTOM>.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    Если таблица хеширования начинается с
    адреса <SPAN LANG="en-US"><I>B</I></SPAN><I>,</I> а ее
    размер равен <SPAN LANG="en-US"><I>H</I></SPAN><I>,</I> то
    вычисляемый методом деления хеш-адрес
    признака определяется по формуле</P>
<P CLASS="western" ALIGN=CENTER STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    <IMG SRC="Тема 7.2.files/form5.png" ALIGN=BOTTOM>.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    Использование <I>метода деления</I> для
    построения функции хеширования позволяет
    получить не только равномерное
    распределение хеш-адресов, но и сократить
    до минимума пространство, отведенное
    для записи идентификаторов ключевых
    слов. Поскольку преобразование в числовую
    форму производится по основанию 26, длину
    таблицы <SPAN LANG="en-US">H</SPAN> следует задавать
    равной простому числу.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    <I>Организация таблицы хеширования</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    Число хеш-адресов в примере ограничено
    количеством различных триграмм, которое
    для 26-буквенного алфавита составляет
    лишь 17576. При использовании клеточной
    структуры размер таблицы хеширования
    будет равен этому числу, умноженному
    на количество позиций в каждой клетке.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    Клетки могут объединяться в <I>связанные
    списки</I>. Хотя метод списков не
    обеспечивает такого быстродействия,
    как обычные процедуры хеширования,
    время выборки оказывается вполне
    приемлемым.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 110%">
    Рассмотренная структура приведена на
    рис. 12.9.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_m2a862f3f.png" NAME="Рисунок 553" ALIGN=BOTTOM WIDTH=613 HEIGHT=600
         BORDER=0></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_734089f2.gif" ALIGN=LEFT><SPAN LANG="en-US"><I>A</I></SPAN><I>,
</I><SPAN LANG="en-US"><I>B</I></SPAN><I>, </I><SPAN LANG="en-US"><I>X</I></SPAN><I>
    – </I>признаки-триграммы. По признаку <SPAN LANG="en-US"><I>A</I></SPAN>
    имеется коллизия, второй элемент,
    отвечающий тому же признаку, помещен в
    следующую по порядку ячейку.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Каждая ячейка таблицы хеширования
    содержит <I>идентификатор некоторой
    триграммы,</I> а также указатель на область
    документов, в которой хранятся искомые
    записи. Сколько признаков содержится
    в заданном поисковом аргументе, столько
    указателей извлекается из индексной
    таблицы хеширования. Если в аргументе
    присутствует хотя бы один из признаков,
    отвечающих правильному ключевому слову,
    то адрес нужной записи дает по меньшей
    мере один указатель. При наличии ошибок
    в поисковом аргументе наряду с верными
    будут выбраны и неправильные указатели.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Далее производится сверка позиций,
    которые триграмма занимает в поисковом
    аргументе и найденной записи. Считается,
    что признаки совпадают, если относительное
    смещение не превышает заданной величины
    (в примере не превышает 2).</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    При вводе в рассмотренный метод
    <I>статистической обработки признаков
    </I>удается выявлять записи, наиболее
    похожие на поисковый аргумент (такой
    способ поиска называют <I>поиском по
    соответствию)</I>. Это можно использовать,
    например, для коррекции неправильно
    произнесенных слов, сравнивая поисковый
    аргумент со всеми хранящимися в словаре
    словами и выбирая то слово, которое в
    наибольшей степени соответствует
    аргументу.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Рассмотрим этот вариант поиска подробнее.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    При совпадении некоторых из признаков
    поискового аргумента с признаками в
    ключевом слове какой-либо конкретной
    записи связанные с этими признаками
    указатели дают в числе других и ее адрес.
    Можно подсчитать количество указателей,
    направленных на каждую запись-кандидата
    (их не больше, чем признаков, извлеченных
    из поискового аргумента). Далее находится
    запись, ключевое слово которой имеет
    максимальное число совпадений с
    аргументом. Учитываются только те
    указатели, у которых в ключевых словах
    смещение признаков относительно тех
    же признаков в поисковом аргументе не
    превышает заданной величины. Можно
    также каким-то образом учитывать и
    другие факторы, например, несовпадение
    размеров ключевых слов.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    При случайно распределенных ошибках
    хорошей мерой несходства, которую можно
    использовать для распознавания ключевых
    слов <SPAN LANG="en-US"><I>X</I></SPAN> и <SPAN LANG="en-US"><I>Y</I></SPAN>,
    служит <I>признаковое расстояние </I><SPAN LANG="en-US"><I>FD</I></SPAN><I>.</I></P>
<P CLASS="western" ALIGN=CENTER STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_m177ee264.gif" ALIGN=BOTTOM><SPAN LANG="fr-FR"><I>FD
    (X, Y) = max   ( n</I></SPAN><SUB><SPAN LANG="fr-FR"><I>x</I></SPAN></SUB><SPAN LANG="fr-FR"><I>,
    n</I></SPAN><SUB><SPAN LANG="fr-FR"><I>y</I></SPAN></SUB><SPAN LANG="fr-FR"><I>
    ) – n</I></SPAN><SUB><SPAN LANG="fr-FR"><I>e </I></SPAN></SUB><SPAN LANG="fr-FR"><I>,</I></SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 130%">
    где <SPAN LANG="en-US"><I>n</I></SPAN><SUB><SPAN LANG="en-US"><I>x</I></SPAN></SUB>и
    <SPAN LANG="en-US"><I>n</I></SPAN><SUB><SPAN LANG="en-US"><I>y</I></SPAN></SUB>
    – количества извлеченных признаков
    соответственно из слов <SPAN LANG="en-US"><I>X</I></SPAN>
    и<SPAN LANG="en-US"><I>Y</I></SPAN><I>,</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.32in; margin-bottom: 0in; line-height: 130%">
    <SPAN LANG="en-US"><I>n</I></SPAN><SUB><SPAN LANG="en-US"><I>e</I></SPAN></SUB>–
    количество не совпавших признаков (в
    рассматриваемом случае равно числу
    указателей ячейки области документов,
    у которых смещения признаков не выходят
    из установленного диапазона).</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    При поиске для подсчета указателей
    строится <I>таблица совпадений</I>.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 130%">
    Указатель заносится в эту таблицу в
    случае, если в его ключевом слове
    обнаруживается такой же признак, как и
    признак в таблице хеширования, по
    которому был найден данный указатель.
    При повторных занесениях данного
    указателя содержимое соответствующего
    ему счетчика в таблице совпадений просто
    увеличивается на 1. Для достижения
    максимального быстродействия (при
    большом количестве поисковых аргументов)
    таблицу совпадений можно организовать
    по принципу хеширования, когда количество
    невелико (а обычно так и бывает), сравнение
    указателей, помещенных в таблицу, может
    осуществляться путем их <I>последовательного
    перебора.</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    Опробование рассмотренного метода
    описано в [9]. Исследовалось действие
    всевозможных типов одиночных и двойных
    ошибок. Источниками ключевых слов
    служили два достаточно больших словаря;
    один из них содержал более тысячи
    наиболее употребительных английских
    слов, второй словарь – известные в науке
    фамилии. Двойные ошибки формировались
    при помощи датчика случайных чисел так,
    что вероятность появления любой
    неправильной буквы в любой позиции была
    одинакова, одиночные ошибки задавались
    поочередно в каждой символьной позиции
    каждого слова.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.49in; margin-bottom: 0in; line-height: 130%">
    По аргументам поиска, содержащим ошибки,
    к каждому из 2-х словарей было произведено
    приблизительно 50 тысяч обращений.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in; margin-bottom: 0in; line-height: 130%">
    Усредненные цифры, выражающие относительное
    количество успешных операций поиска,
    приведены в табл. 12.1.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in; margin-bottom: 0in; line-height: 130%">
    Уровень 1 – относится к тем реализациям,
    в которых правильное слово имеет
    минимальное значение признакового
    расстояния <SPAN LANG="en-US"><I>FD</I></SPAN> среди
    всех кандидатов на выборку.
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in; margin-bottom: 0in; line-height: 130%">
    Уровень 2 – относится к реализациям, в
    которых правильному слову соответствовал
    либо наименьший показатель <SPAN LANG="en-US"><I>FD</I></SPAN><I>,</I>
    либо ближайший к нему.</P>
<p>Таблица 12.1. Относительное количество успешных операций поиска</p>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 130%"><A NAME="_GoBack"></A>
    <IMG SRC="Тема 7.2.files/i_6936822e08b74235_html_6e22fcc.png" NAME="Рисунок 554" ALIGN=BOTTOM WIDTH=624 HEIGHT=458
         BORDER=0></P>
<P CLASS="western" STYLE="margin-bottom: 0in"><BR>
</P>
<DIV TYPE=FOOTER>
    <P STYLE="margin-top: 0.26in; margin-bottom: 0in; border: none; padding: 0in">

    <P STYLE="margin-right: 0.25in; text-indent: 0.25in; margin-bottom: 0in">
        <BR>
    </P>
</DIV>
<p><a href="Тема 7.1.htm">Предыдущая </a>
    <a href="Тема 8.1.htm"> Следующая</a></p>
</BODY>
</HTML>
